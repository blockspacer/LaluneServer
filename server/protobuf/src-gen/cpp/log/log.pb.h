// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: log/log.proto

#ifndef PROTOBUF_log_2flog_2eproto__INCLUDED
#define PROTOBUF_log_2flog_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace kit {
namespace log {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_log_2flog_2eproto();
void protobuf_AssignDesc_log_2flog_2eproto();
void protobuf_ShutdownFile_log_2flog_2eproto();

class LexicalEntry;
class LogDetail;
class LogEvent;
class Login;
class LogOption;
class LogOptions;
class Query;
class QueryResult;

// ===================================================================

class LexicalEntry : public ::google::protobuf::Message {
 public:
  LexicalEntry();
  virtual ~LexicalEntry();

  LexicalEntry(const LexicalEntry& from);

  inline LexicalEntry& operator=(const LexicalEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LexicalEntry& default_instance();

  void Swap(LexicalEntry* other);

  // implements Message ----------------------------------------------

  LexicalEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LexicalEntry& from);
  void MergeFrom(const LexicalEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string entry_name = 2;
  inline bool has_entry_name() const;
  inline void clear_entry_name();
  static const int kEntryNameFieldNumber = 2;
  inline const ::std::string& entry_name() const;
  inline void set_entry_name(const ::std::string& value);
  inline void set_entry_name(const char* value);
  inline void set_entry_name(const char* value, size_t size);
  inline ::std::string* mutable_entry_name();
  inline ::std::string* release_entry_name();
  inline void set_allocated_entry_name(::std::string* entry_name);

  // required int32 value_type = 1;
  inline bool has_value_type() const;
  inline void clear_value_type();
  static const int kValueTypeFieldNumber = 1;
  inline ::google::protobuf::int32 value_type() const;
  inline void set_value_type(::google::protobuf::int32 value);

  // optional uint64 u = 3;
  inline bool has_u() const;
  inline void clear_u();
  static const int kUFieldNumber = 3;
  inline ::google::protobuf::uint64 u() const;
  inline void set_u(::google::protobuf::uint64 value);

  // optional sint64 i = 4;
  inline bool has_i() const;
  inline void clear_i();
  static const int kIFieldNumber = 4;
  inline ::google::protobuf::int64 i() const;
  inline void set_i(::google::protobuf::int64 value);

  // optional string s = 5;
  inline bool has_s() const;
  inline void clear_s();
  static const int kSFieldNumber = 5;
  inline const ::std::string& s() const;
  inline void set_s(const ::std::string& value);
  inline void set_s(const char* value);
  inline void set_s(const char* value, size_t size);
  inline ::std::string* mutable_s();
  inline ::std::string* release_s();
  inline void set_allocated_s(::std::string* s);

  // optional bytes b = 6;
  inline bool has_b() const;
  inline void clear_b();
  static const int kBFieldNumber = 6;
  inline const ::std::string& b() const;
  inline void set_b(const ::std::string& value);
  inline void set_b(const char* value);
  inline void set_b(const void* value, size_t size);
  inline ::std::string* mutable_b();
  inline ::std::string* release_b();
  inline void set_allocated_b(::std::string* b);

  // optional double d = 7;
  inline bool has_d() const;
  inline void clear_d();
  static const int kDFieldNumber = 7;
  inline double d() const;
  inline void set_d(double value);

  // @@protoc_insertion_point(class_scope:kit.log.LexicalEntry)
 private:
  inline void set_has_entry_name();
  inline void clear_has_entry_name();
  inline void set_has_value_type();
  inline void clear_has_value_type();
  inline void set_has_u();
  inline void clear_has_u();
  inline void set_has_i();
  inline void clear_has_i();
  inline void set_has_s();
  inline void clear_has_s();
  inline void set_has_b();
  inline void clear_has_b();
  inline void set_has_d();
  inline void clear_has_d();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* entry_name_;
  ::google::protobuf::uint64 u_;
  ::google::protobuf::int64 i_;
  ::std::string* s_;
  ::std::string* b_;
  double d_;
  ::google::protobuf::int32 value_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_log_2flog_2eproto();
  friend void protobuf_AssignDesc_log_2flog_2eproto();
  friend void protobuf_ShutdownFile_log_2flog_2eproto();

  void InitAsDefaultInstance();
  static LexicalEntry* default_instance_;
};
// -------------------------------------------------------------------

class LogDetail : public ::google::protobuf::Message {
 public:
  LogDetail();
  virtual ~LogDetail();

  LogDetail(const LogDetail& from);

  inline LogDetail& operator=(const LogDetail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogDetail& default_instance();

  void Swap(LogDetail* other);

  // implements Message ----------------------------------------------

  LogDetail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogDetail& from);
  void MergeFrom(const LogDetail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kit.log.LexicalEntry entry = 1;
  inline int entry_size() const;
  inline void clear_entry();
  static const int kEntryFieldNumber = 1;
  inline const ::kit::log::LexicalEntry& entry(int index) const;
  inline ::kit::log::LexicalEntry* mutable_entry(int index);
  inline ::kit::log::LexicalEntry* add_entry();
  inline const ::google::protobuf::RepeatedPtrField< ::kit::log::LexicalEntry >&
      entry() const;
  inline ::google::protobuf::RepeatedPtrField< ::kit::log::LexicalEntry >*
      mutable_entry();

  // @@protoc_insertion_point(class_scope:kit.log.LogDetail)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::kit::log::LexicalEntry > entry_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_log_2flog_2eproto();
  friend void protobuf_AssignDesc_log_2flog_2eproto();
  friend void protobuf_ShutdownFile_log_2flog_2eproto();

  void InitAsDefaultInstance();
  static LogDetail* default_instance_;
};
// -------------------------------------------------------------------

class LogEvent : public ::google::protobuf::Message {
 public:
  LogEvent();
  virtual ~LogEvent();

  LogEvent(const LogEvent& from);

  inline LogEvent& operator=(const LogEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogEvent& default_instance();

  void Swap(LogEvent* other);

  // implements Message ----------------------------------------------

  LogEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogEvent& from);
  void MergeFrom(const LogEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string index1 = 4;
  inline bool has_index1() const;
  inline void clear_index1();
  static const int kIndex1FieldNumber = 4;
  inline const ::std::string& index1() const;
  inline void set_index1(const ::std::string& value);
  inline void set_index1(const char* value);
  inline void set_index1(const char* value, size_t size);
  inline ::std::string* mutable_index1();
  inline ::std::string* release_index1();
  inline void set_allocated_index1(::std::string* index1);

  // optional string index2 = 5;
  inline bool has_index2() const;
  inline void clear_index2();
  static const int kIndex2FieldNumber = 5;
  inline const ::std::string& index2() const;
  inline void set_index2(const ::std::string& value);
  inline void set_index2(const char* value);
  inline void set_index2(const char* value, size_t size);
  inline ::std::string* mutable_index2();
  inline ::std::string* release_index2();
  inline void set_allocated_index2(::std::string* index2);

  // required string index3 = 1;
  inline bool has_index3() const;
  inline void clear_index3();
  static const int kIndex3FieldNumber = 1;
  inline const ::std::string& index3() const;
  inline void set_index3(const ::std::string& value);
  inline void set_index3(const char* value);
  inline void set_index3(const char* value, size_t size);
  inline ::std::string* mutable_index3();
  inline ::std::string* release_index3();
  inline void set_allocated_index3(::std::string* index3);

  // required uint64 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // required bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:kit.log.LogEvent)
 private:
  inline void set_has_index1();
  inline void clear_has_index1();
  inline void set_has_index2();
  inline void clear_has_index2();
  inline void set_has_index3();
  inline void clear_has_index3();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* index1_;
  ::std::string* index2_;
  ::std::string* index3_;
  ::google::protobuf::uint64 time_;
  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_log_2flog_2eproto();
  friend void protobuf_AssignDesc_log_2flog_2eproto();
  friend void protobuf_ShutdownFile_log_2flog_2eproto();

  void InitAsDefaultInstance();
  static LogEvent* default_instance_;
};
// -------------------------------------------------------------------

class Login : public ::google::protobuf::Message {
 public:
  Login();
  virtual ~Login();

  Login(const Login& from);

  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Login& default_instance();

  void Swap(Login* other);

  // implements Message ----------------------------------------------

  Login* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Login& from);
  void MergeFrom(const Login& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string index1 = 1;
  inline bool has_index1() const;
  inline void clear_index1();
  static const int kIndex1FieldNumber = 1;
  inline const ::std::string& index1() const;
  inline void set_index1(const ::std::string& value);
  inline void set_index1(const char* value);
  inline void set_index1(const char* value, size_t size);
  inline ::std::string* mutable_index1();
  inline ::std::string* release_index1();
  inline void set_allocated_index1(::std::string* index1);

  // optional string index2 = 2;
  inline bool has_index2() const;
  inline void clear_index2();
  static const int kIndex2FieldNumber = 2;
  inline const ::std::string& index2() const;
  inline void set_index2(const ::std::string& value);
  inline void set_index2(const char* value);
  inline void set_index2(const char* value, size_t size);
  inline ::std::string* mutable_index2();
  inline ::std::string* release_index2();
  inline void set_allocated_index2(::std::string* index2);

  // optional string username = 3;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 3;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string password = 4;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 4;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:kit.log.Login)
 private:
  inline void set_has_index1();
  inline void clear_has_index1();
  inline void set_has_index2();
  inline void clear_has_index2();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* index1_;
  ::std::string* index2_;
  ::std::string* username_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_log_2flog_2eproto();
  friend void protobuf_AssignDesc_log_2flog_2eproto();
  friend void protobuf_ShutdownFile_log_2flog_2eproto();

  void InitAsDefaultInstance();
  static Login* default_instance_;
};
// -------------------------------------------------------------------

class LogOption : public ::google::protobuf::Message {
 public:
  LogOption();
  virtual ~LogOption();

  LogOption(const LogOption& from);

  inline LogOption& operator=(const LogOption& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogOption& default_instance();

  void Swap(LogOption* other);

  // implements Message ----------------------------------------------

  LogOption* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogOption& from);
  void MergeFrom(const LogOption& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string index3 = 1;
  inline bool has_index3() const;
  inline void clear_index3();
  static const int kIndex3FieldNumber = 1;
  inline const ::std::string& index3() const;
  inline void set_index3(const ::std::string& value);
  inline void set_index3(const char* value);
  inline void set_index3(const char* value, size_t size);
  inline ::std::string* mutable_index3();
  inline ::std::string* release_index3();
  inline void set_allocated_index3(::std::string* index3);

  // required uint32 log_level = 2;
  inline bool has_log_level() const;
  inline void clear_log_level();
  static const int kLogLevelFieldNumber = 2;
  inline ::google::protobuf::uint32 log_level() const;
  inline void set_log_level(::google::protobuf::uint32 value);

  // required uint32 count_interval = 3;
  inline bool has_count_interval() const;
  inline void clear_count_interval();
  static const int kCountIntervalFieldNumber = 3;
  inline ::google::protobuf::uint32 count_interval() const;
  inline void set_count_interval(::google::protobuf::uint32 value);

  // required uint32 enable_detail = 4;
  inline bool has_enable_detail() const;
  inline void clear_enable_detail();
  static const int kEnableDetailFieldNumber = 4;
  inline ::google::protobuf::uint32 enable_detail() const;
  inline void set_enable_detail(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:kit.log.LogOption)
 private:
  inline void set_has_index3();
  inline void clear_has_index3();
  inline void set_has_log_level();
  inline void clear_has_log_level();
  inline void set_has_count_interval();
  inline void clear_has_count_interval();
  inline void set_has_enable_detail();
  inline void clear_has_enable_detail();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* index3_;
  ::google::protobuf::uint32 log_level_;
  ::google::protobuf::uint32 count_interval_;
  ::google::protobuf::uint32 enable_detail_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_log_2flog_2eproto();
  friend void protobuf_AssignDesc_log_2flog_2eproto();
  friend void protobuf_ShutdownFile_log_2flog_2eproto();

  void InitAsDefaultInstance();
  static LogOption* default_instance_;
};
// -------------------------------------------------------------------

class LogOptions : public ::google::protobuf::Message {
 public:
  LogOptions();
  virtual ~LogOptions();

  LogOptions(const LogOptions& from);

  inline LogOptions& operator=(const LogOptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogOptions& default_instance();

  void Swap(LogOptions* other);

  // implements Message ----------------------------------------------

  LogOptions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogOptions& from);
  void MergeFrom(const LogOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 log_level = 2;
  inline bool has_log_level() const;
  inline void clear_log_level();
  static const int kLogLevelFieldNumber = 2;
  inline ::google::protobuf::uint32 log_level() const;
  inline void set_log_level(::google::protobuf::uint32 value);

  // optional uint32 count_interval = 3;
  inline bool has_count_interval() const;
  inline void clear_count_interval();
  static const int kCountIntervalFieldNumber = 3;
  inline ::google::protobuf::uint32 count_interval() const;
  inline void set_count_interval(::google::protobuf::uint32 value);

  // optional uint32 enable_detail = 4;
  inline bool has_enable_detail() const;
  inline void clear_enable_detail();
  static const int kEnableDetailFieldNumber = 4;
  inline ::google::protobuf::uint32 enable_detail() const;
  inline void set_enable_detail(::google::protobuf::uint32 value);

  // repeated .kit.log.LogOption log_option = 1;
  inline int log_option_size() const;
  inline void clear_log_option();
  static const int kLogOptionFieldNumber = 1;
  inline const ::kit::log::LogOption& log_option(int index) const;
  inline ::kit::log::LogOption* mutable_log_option(int index);
  inline ::kit::log::LogOption* add_log_option();
  inline const ::google::protobuf::RepeatedPtrField< ::kit::log::LogOption >&
      log_option() const;
  inline ::google::protobuf::RepeatedPtrField< ::kit::log::LogOption >*
      mutable_log_option();

  // @@protoc_insertion_point(class_scope:kit.log.LogOptions)
 private:
  inline void set_has_log_level();
  inline void clear_has_log_level();
  inline void set_has_count_interval();
  inline void clear_has_count_interval();
  inline void set_has_enable_detail();
  inline void clear_has_enable_detail();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 log_level_;
  ::google::protobuf::uint32 count_interval_;
  ::google::protobuf::RepeatedPtrField< ::kit::log::LogOption > log_option_;
  ::google::protobuf::uint32 enable_detail_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_log_2flog_2eproto();
  friend void protobuf_AssignDesc_log_2flog_2eproto();
  friend void protobuf_ShutdownFile_log_2flog_2eproto();

  void InitAsDefaultInstance();
  static LogOptions* default_instance_;
};
// -------------------------------------------------------------------

class Query : public ::google::protobuf::Message {
 public:
  Query();
  virtual ~Query();

  Query(const Query& from);

  inline Query& operator=(const Query& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Query& default_instance();

  void Swap(Query* other);

  // implements Message ----------------------------------------------

  Query* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Query& from);
  void MergeFrom(const Query& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string index1 = 1;
  inline bool has_index1() const;
  inline void clear_index1();
  static const int kIndex1FieldNumber = 1;
  inline const ::std::string& index1() const;
  inline void set_index1(const ::std::string& value);
  inline void set_index1(const char* value);
  inline void set_index1(const char* value, size_t size);
  inline ::std::string* mutable_index1();
  inline ::std::string* release_index1();
  inline void set_allocated_index1(::std::string* index1);

  // optional string index2 = 2;
  inline bool has_index2() const;
  inline void clear_index2();
  static const int kIndex2FieldNumber = 2;
  inline const ::std::string& index2() const;
  inline void set_index2(const ::std::string& value);
  inline void set_index2(const char* value);
  inline void set_index2(const char* value, size_t size);
  inline ::std::string* mutable_index2();
  inline ::std::string* release_index2();
  inline void set_allocated_index2(::std::string* index2);

  // optional string index3 = 3;
  inline bool has_index3() const;
  inline void clear_index3();
  static const int kIndex3FieldNumber = 3;
  inline const ::std::string& index3() const;
  inline void set_index3(const ::std::string& value);
  inline void set_index3(const char* value);
  inline void set_index3(const char* value, size_t size);
  inline ::std::string* mutable_index3();
  inline ::std::string* release_index3();
  inline void set_allocated_index3(::std::string* index3);

  // optional uint64 begin_time = 7;
  inline bool has_begin_time() const;
  inline void clear_begin_time();
  static const int kBeginTimeFieldNumber = 7;
  inline ::google::protobuf::uint64 begin_time() const;
  inline void set_begin_time(::google::protobuf::uint64 value);

  // optional uint64 end_time = 8;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 8;
  inline ::google::protobuf::uint64 end_time() const;
  inline void set_end_time(::google::protobuf::uint64 value);

  // optional int32 no_sort = 4;
  inline bool has_no_sort() const;
  inline void clear_no_sort();
  static const int kNoSortFieldNumber = 4;
  inline ::google::protobuf::int32 no_sort() const;
  inline void set_no_sort(::google::protobuf::int32 value);

  // optional string condition_clause = 5;
  inline bool has_condition_clause() const;
  inline void clear_condition_clause();
  static const int kConditionClauseFieldNumber = 5;
  inline const ::std::string& condition_clause() const;
  inline void set_condition_clause(const ::std::string& value);
  inline void set_condition_clause(const char* value);
  inline void set_condition_clause(const char* value, size_t size);
  inline ::std::string* mutable_condition_clause();
  inline ::std::string* release_condition_clause();
  inline void set_allocated_condition_clause(::std::string* condition_clause);

  // optional int32 is_count = 6;
  inline bool has_is_count() const;
  inline void clear_is_count();
  static const int kIsCountFieldNumber = 6;
  inline ::google::protobuf::int32 is_count() const;
  inline void set_is_count(::google::protobuf::int32 value);

  // optional int32 limit_a = 9;
  inline bool has_limit_a() const;
  inline void clear_limit_a();
  static const int kLimitAFieldNumber = 9;
  inline ::google::protobuf::int32 limit_a() const;
  inline void set_limit_a(::google::protobuf::int32 value);

  // optional int32 limit_b = 10;
  inline bool has_limit_b() const;
  inline void clear_limit_b();
  static const int kLimitBFieldNumber = 10;
  inline ::google::protobuf::int32 limit_b() const;
  inline void set_limit_b(::google::protobuf::int32 value);

  // optional string username = 11;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 11;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string password = 12;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 12;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:kit.log.Query)
 private:
  inline void set_has_index1();
  inline void clear_has_index1();
  inline void set_has_index2();
  inline void clear_has_index2();
  inline void set_has_index3();
  inline void clear_has_index3();
  inline void set_has_begin_time();
  inline void clear_has_begin_time();
  inline void set_has_end_time();
  inline void clear_has_end_time();
  inline void set_has_no_sort();
  inline void clear_has_no_sort();
  inline void set_has_condition_clause();
  inline void clear_has_condition_clause();
  inline void set_has_is_count();
  inline void clear_has_is_count();
  inline void set_has_limit_a();
  inline void clear_has_limit_a();
  inline void set_has_limit_b();
  inline void clear_has_limit_b();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* index1_;
  ::std::string* index2_;
  ::std::string* index3_;
  ::google::protobuf::uint64 begin_time_;
  ::google::protobuf::uint64 end_time_;
  ::std::string* condition_clause_;
  ::google::protobuf::int32 no_sort_;
  ::google::protobuf::int32 is_count_;
  ::google::protobuf::int32 limit_a_;
  ::google::protobuf::int32 limit_b_;
  ::std::string* username_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_log_2flog_2eproto();
  friend void protobuf_AssignDesc_log_2flog_2eproto();
  friend void protobuf_ShutdownFile_log_2flog_2eproto();

  void InitAsDefaultInstance();
  static Query* default_instance_;
};
// -------------------------------------------------------------------

class QueryResult : public ::google::protobuf::Message {
 public:
  QueryResult();
  virtual ~QueryResult();

  QueryResult(const QueryResult& from);

  inline QueryResult& operator=(const QueryResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryResult& default_instance();

  void Swap(QueryResult* other);

  // implements Message ----------------------------------------------

  QueryResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QueryResult& from);
  void MergeFrom(const QueryResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kit.log.LogEvent log_event = 1;
  inline int log_event_size() const;
  inline void clear_log_event();
  static const int kLogEventFieldNumber = 1;
  inline const ::kit::log::LogEvent& log_event(int index) const;
  inline ::kit::log::LogEvent* mutable_log_event(int index);
  inline ::kit::log::LogEvent* add_log_event();
  inline const ::google::protobuf::RepeatedPtrField< ::kit::log::LogEvent >&
      log_event() const;
  inline ::google::protobuf::RepeatedPtrField< ::kit::log::LogEvent >*
      mutable_log_event();

  // @@protoc_insertion_point(class_scope:kit.log.QueryResult)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::kit::log::LogEvent > log_event_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_log_2flog_2eproto();
  friend void protobuf_AssignDesc_log_2flog_2eproto();
  friend void protobuf_ShutdownFile_log_2flog_2eproto();

  void InitAsDefaultInstance();
  static QueryResult* default_instance_;
};
// ===================================================================


// ===================================================================

// LexicalEntry

// optional string entry_name = 2;
inline bool LexicalEntry::has_entry_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LexicalEntry::set_has_entry_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LexicalEntry::clear_has_entry_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LexicalEntry::clear_entry_name() {
  if (entry_name_ != &::google::protobuf::internal::kEmptyString) {
    entry_name_->clear();
  }
  clear_has_entry_name();
}
inline const ::std::string& LexicalEntry::entry_name() const {
  return *entry_name_;
}
inline void LexicalEntry::set_entry_name(const ::std::string& value) {
  set_has_entry_name();
  if (entry_name_ == &::google::protobuf::internal::kEmptyString) {
    entry_name_ = new ::std::string;
  }
  entry_name_->assign(value);
}
inline void LexicalEntry::set_entry_name(const char* value) {
  set_has_entry_name();
  if (entry_name_ == &::google::protobuf::internal::kEmptyString) {
    entry_name_ = new ::std::string;
  }
  entry_name_->assign(value);
}
inline void LexicalEntry::set_entry_name(const char* value, size_t size) {
  set_has_entry_name();
  if (entry_name_ == &::google::protobuf::internal::kEmptyString) {
    entry_name_ = new ::std::string;
  }
  entry_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LexicalEntry::mutable_entry_name() {
  set_has_entry_name();
  if (entry_name_ == &::google::protobuf::internal::kEmptyString) {
    entry_name_ = new ::std::string;
  }
  return entry_name_;
}
inline ::std::string* LexicalEntry::release_entry_name() {
  clear_has_entry_name();
  if (entry_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entry_name_;
    entry_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LexicalEntry::set_allocated_entry_name(::std::string* entry_name) {
  if (entry_name_ != &::google::protobuf::internal::kEmptyString) {
    delete entry_name_;
  }
  if (entry_name) {
    set_has_entry_name();
    entry_name_ = entry_name;
  } else {
    clear_has_entry_name();
    entry_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 value_type = 1;
inline bool LexicalEntry::has_value_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LexicalEntry::set_has_value_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LexicalEntry::clear_has_value_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LexicalEntry::clear_value_type() {
  value_type_ = 0;
  clear_has_value_type();
}
inline ::google::protobuf::int32 LexicalEntry::value_type() const {
  return value_type_;
}
inline void LexicalEntry::set_value_type(::google::protobuf::int32 value) {
  set_has_value_type();
  value_type_ = value;
}

// optional uint64 u = 3;
inline bool LexicalEntry::has_u() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LexicalEntry::set_has_u() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LexicalEntry::clear_has_u() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LexicalEntry::clear_u() {
  u_ = GOOGLE_ULONGLONG(0);
  clear_has_u();
}
inline ::google::protobuf::uint64 LexicalEntry::u() const {
  return u_;
}
inline void LexicalEntry::set_u(::google::protobuf::uint64 value) {
  set_has_u();
  u_ = value;
}

// optional sint64 i = 4;
inline bool LexicalEntry::has_i() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LexicalEntry::set_has_i() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LexicalEntry::clear_has_i() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LexicalEntry::clear_i() {
  i_ = GOOGLE_LONGLONG(0);
  clear_has_i();
}
inline ::google::protobuf::int64 LexicalEntry::i() const {
  return i_;
}
inline void LexicalEntry::set_i(::google::protobuf::int64 value) {
  set_has_i();
  i_ = value;
}

// optional string s = 5;
inline bool LexicalEntry::has_s() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LexicalEntry::set_has_s() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LexicalEntry::clear_has_s() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LexicalEntry::clear_s() {
  if (s_ != &::google::protobuf::internal::kEmptyString) {
    s_->clear();
  }
  clear_has_s();
}
inline const ::std::string& LexicalEntry::s() const {
  return *s_;
}
inline void LexicalEntry::set_s(const ::std::string& value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::kEmptyString) {
    s_ = new ::std::string;
  }
  s_->assign(value);
}
inline void LexicalEntry::set_s(const char* value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::kEmptyString) {
    s_ = new ::std::string;
  }
  s_->assign(value);
}
inline void LexicalEntry::set_s(const char* value, size_t size) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::kEmptyString) {
    s_ = new ::std::string;
  }
  s_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LexicalEntry::mutable_s() {
  set_has_s();
  if (s_ == &::google::protobuf::internal::kEmptyString) {
    s_ = new ::std::string;
  }
  return s_;
}
inline ::std::string* LexicalEntry::release_s() {
  clear_has_s();
  if (s_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = s_;
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LexicalEntry::set_allocated_s(::std::string* s) {
  if (s_ != &::google::protobuf::internal::kEmptyString) {
    delete s_;
  }
  if (s) {
    set_has_s();
    s_ = s;
  } else {
    clear_has_s();
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes b = 6;
inline bool LexicalEntry::has_b() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LexicalEntry::set_has_b() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LexicalEntry::clear_has_b() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LexicalEntry::clear_b() {
  if (b_ != &::google::protobuf::internal::kEmptyString) {
    b_->clear();
  }
  clear_has_b();
}
inline const ::std::string& LexicalEntry::b() const {
  return *b_;
}
inline void LexicalEntry::set_b(const ::std::string& value) {
  set_has_b();
  if (b_ == &::google::protobuf::internal::kEmptyString) {
    b_ = new ::std::string;
  }
  b_->assign(value);
}
inline void LexicalEntry::set_b(const char* value) {
  set_has_b();
  if (b_ == &::google::protobuf::internal::kEmptyString) {
    b_ = new ::std::string;
  }
  b_->assign(value);
}
inline void LexicalEntry::set_b(const void* value, size_t size) {
  set_has_b();
  if (b_ == &::google::protobuf::internal::kEmptyString) {
    b_ = new ::std::string;
  }
  b_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LexicalEntry::mutable_b() {
  set_has_b();
  if (b_ == &::google::protobuf::internal::kEmptyString) {
    b_ = new ::std::string;
  }
  return b_;
}
inline ::std::string* LexicalEntry::release_b() {
  clear_has_b();
  if (b_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = b_;
    b_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LexicalEntry::set_allocated_b(::std::string* b) {
  if (b_ != &::google::protobuf::internal::kEmptyString) {
    delete b_;
  }
  if (b) {
    set_has_b();
    b_ = b;
  } else {
    clear_has_b();
    b_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double d = 7;
inline bool LexicalEntry::has_d() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LexicalEntry::set_has_d() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LexicalEntry::clear_has_d() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LexicalEntry::clear_d() {
  d_ = 0;
  clear_has_d();
}
inline double LexicalEntry::d() const {
  return d_;
}
inline void LexicalEntry::set_d(double value) {
  set_has_d();
  d_ = value;
}

// -------------------------------------------------------------------

// LogDetail

// repeated .kit.log.LexicalEntry entry = 1;
inline int LogDetail::entry_size() const {
  return entry_.size();
}
inline void LogDetail::clear_entry() {
  entry_.Clear();
}
inline const ::kit::log::LexicalEntry& LogDetail::entry(int index) const {
  return entry_.Get(index);
}
inline ::kit::log::LexicalEntry* LogDetail::mutable_entry(int index) {
  return entry_.Mutable(index);
}
inline ::kit::log::LexicalEntry* LogDetail::add_entry() {
  return entry_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kit::log::LexicalEntry >&
LogDetail::entry() const {
  return entry_;
}
inline ::google::protobuf::RepeatedPtrField< ::kit::log::LexicalEntry >*
LogDetail::mutable_entry() {
  return &entry_;
}

// -------------------------------------------------------------------

// LogEvent

// optional string index1 = 4;
inline bool LogEvent::has_index1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogEvent::set_has_index1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogEvent::clear_has_index1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogEvent::clear_index1() {
  if (index1_ != &::google::protobuf::internal::kEmptyString) {
    index1_->clear();
  }
  clear_has_index1();
}
inline const ::std::string& LogEvent::index1() const {
  return *index1_;
}
inline void LogEvent::set_index1(const ::std::string& value) {
  set_has_index1();
  if (index1_ == &::google::protobuf::internal::kEmptyString) {
    index1_ = new ::std::string;
  }
  index1_->assign(value);
}
inline void LogEvent::set_index1(const char* value) {
  set_has_index1();
  if (index1_ == &::google::protobuf::internal::kEmptyString) {
    index1_ = new ::std::string;
  }
  index1_->assign(value);
}
inline void LogEvent::set_index1(const char* value, size_t size) {
  set_has_index1();
  if (index1_ == &::google::protobuf::internal::kEmptyString) {
    index1_ = new ::std::string;
  }
  index1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogEvent::mutable_index1() {
  set_has_index1();
  if (index1_ == &::google::protobuf::internal::kEmptyString) {
    index1_ = new ::std::string;
  }
  return index1_;
}
inline ::std::string* LogEvent::release_index1() {
  clear_has_index1();
  if (index1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = index1_;
    index1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogEvent::set_allocated_index1(::std::string* index1) {
  if (index1_ != &::google::protobuf::internal::kEmptyString) {
    delete index1_;
  }
  if (index1) {
    set_has_index1();
    index1_ = index1;
  } else {
    clear_has_index1();
    index1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string index2 = 5;
inline bool LogEvent::has_index2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogEvent::set_has_index2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogEvent::clear_has_index2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogEvent::clear_index2() {
  if (index2_ != &::google::protobuf::internal::kEmptyString) {
    index2_->clear();
  }
  clear_has_index2();
}
inline const ::std::string& LogEvent::index2() const {
  return *index2_;
}
inline void LogEvent::set_index2(const ::std::string& value) {
  set_has_index2();
  if (index2_ == &::google::protobuf::internal::kEmptyString) {
    index2_ = new ::std::string;
  }
  index2_->assign(value);
}
inline void LogEvent::set_index2(const char* value) {
  set_has_index2();
  if (index2_ == &::google::protobuf::internal::kEmptyString) {
    index2_ = new ::std::string;
  }
  index2_->assign(value);
}
inline void LogEvent::set_index2(const char* value, size_t size) {
  set_has_index2();
  if (index2_ == &::google::protobuf::internal::kEmptyString) {
    index2_ = new ::std::string;
  }
  index2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogEvent::mutable_index2() {
  set_has_index2();
  if (index2_ == &::google::protobuf::internal::kEmptyString) {
    index2_ = new ::std::string;
  }
  return index2_;
}
inline ::std::string* LogEvent::release_index2() {
  clear_has_index2();
  if (index2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = index2_;
    index2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogEvent::set_allocated_index2(::std::string* index2) {
  if (index2_ != &::google::protobuf::internal::kEmptyString) {
    delete index2_;
  }
  if (index2) {
    set_has_index2();
    index2_ = index2;
  } else {
    clear_has_index2();
    index2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string index3 = 1;
inline bool LogEvent::has_index3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogEvent::set_has_index3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogEvent::clear_has_index3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogEvent::clear_index3() {
  if (index3_ != &::google::protobuf::internal::kEmptyString) {
    index3_->clear();
  }
  clear_has_index3();
}
inline const ::std::string& LogEvent::index3() const {
  return *index3_;
}
inline void LogEvent::set_index3(const ::std::string& value) {
  set_has_index3();
  if (index3_ == &::google::protobuf::internal::kEmptyString) {
    index3_ = new ::std::string;
  }
  index3_->assign(value);
}
inline void LogEvent::set_index3(const char* value) {
  set_has_index3();
  if (index3_ == &::google::protobuf::internal::kEmptyString) {
    index3_ = new ::std::string;
  }
  index3_->assign(value);
}
inline void LogEvent::set_index3(const char* value, size_t size) {
  set_has_index3();
  if (index3_ == &::google::protobuf::internal::kEmptyString) {
    index3_ = new ::std::string;
  }
  index3_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogEvent::mutable_index3() {
  set_has_index3();
  if (index3_ == &::google::protobuf::internal::kEmptyString) {
    index3_ = new ::std::string;
  }
  return index3_;
}
inline ::std::string* LogEvent::release_index3() {
  clear_has_index3();
  if (index3_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = index3_;
    index3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogEvent::set_allocated_index3(::std::string* index3) {
  if (index3_ != &::google::protobuf::internal::kEmptyString) {
    delete index3_;
  }
  if (index3) {
    set_has_index3();
    index3_ = index3;
  } else {
    clear_has_index3();
    index3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 time = 2;
inline bool LogEvent::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LogEvent::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LogEvent::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LogEvent::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 LogEvent::time() const {
  return time_;
}
inline void LogEvent::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
}

// required bytes data = 3;
inline bool LogEvent::has_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LogEvent::set_has_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LogEvent::clear_has_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LogEvent::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& LogEvent::data() const {
  return *data_;
}
inline void LogEvent::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void LogEvent::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void LogEvent::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogEvent::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* LogEvent::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogEvent::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Login

// optional string index1 = 1;
inline bool Login::has_index1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Login::set_has_index1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Login::clear_has_index1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Login::clear_index1() {
  if (index1_ != &::google::protobuf::internal::kEmptyString) {
    index1_->clear();
  }
  clear_has_index1();
}
inline const ::std::string& Login::index1() const {
  return *index1_;
}
inline void Login::set_index1(const ::std::string& value) {
  set_has_index1();
  if (index1_ == &::google::protobuf::internal::kEmptyString) {
    index1_ = new ::std::string;
  }
  index1_->assign(value);
}
inline void Login::set_index1(const char* value) {
  set_has_index1();
  if (index1_ == &::google::protobuf::internal::kEmptyString) {
    index1_ = new ::std::string;
  }
  index1_->assign(value);
}
inline void Login::set_index1(const char* value, size_t size) {
  set_has_index1();
  if (index1_ == &::google::protobuf::internal::kEmptyString) {
    index1_ = new ::std::string;
  }
  index1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login::mutable_index1() {
  set_has_index1();
  if (index1_ == &::google::protobuf::internal::kEmptyString) {
    index1_ = new ::std::string;
  }
  return index1_;
}
inline ::std::string* Login::release_index1() {
  clear_has_index1();
  if (index1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = index1_;
    index1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Login::set_allocated_index1(::std::string* index1) {
  if (index1_ != &::google::protobuf::internal::kEmptyString) {
    delete index1_;
  }
  if (index1) {
    set_has_index1();
    index1_ = index1;
  } else {
    clear_has_index1();
    index1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string index2 = 2;
inline bool Login::has_index2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Login::set_has_index2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Login::clear_has_index2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Login::clear_index2() {
  if (index2_ != &::google::protobuf::internal::kEmptyString) {
    index2_->clear();
  }
  clear_has_index2();
}
inline const ::std::string& Login::index2() const {
  return *index2_;
}
inline void Login::set_index2(const ::std::string& value) {
  set_has_index2();
  if (index2_ == &::google::protobuf::internal::kEmptyString) {
    index2_ = new ::std::string;
  }
  index2_->assign(value);
}
inline void Login::set_index2(const char* value) {
  set_has_index2();
  if (index2_ == &::google::protobuf::internal::kEmptyString) {
    index2_ = new ::std::string;
  }
  index2_->assign(value);
}
inline void Login::set_index2(const char* value, size_t size) {
  set_has_index2();
  if (index2_ == &::google::protobuf::internal::kEmptyString) {
    index2_ = new ::std::string;
  }
  index2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login::mutable_index2() {
  set_has_index2();
  if (index2_ == &::google::protobuf::internal::kEmptyString) {
    index2_ = new ::std::string;
  }
  return index2_;
}
inline ::std::string* Login::release_index2() {
  clear_has_index2();
  if (index2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = index2_;
    index2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Login::set_allocated_index2(::std::string* index2) {
  if (index2_ != &::google::protobuf::internal::kEmptyString) {
    delete index2_;
  }
  if (index2) {
    set_has_index2();
    index2_ = index2;
  } else {
    clear_has_index2();
    index2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string username = 3;
inline bool Login::has_username() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Login::set_has_username() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Login::clear_has_username() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Login::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& Login::username() const {
  return *username_;
}
inline void Login::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void Login::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void Login::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* Login::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Login::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 4;
inline bool Login::has_password() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Login::set_has_password() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Login::clear_has_password() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Login::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& Login::password() const {
  return *password_;
}
inline void Login::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void Login::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void Login::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* Login::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Login::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LogOption

// required string index3 = 1;
inline bool LogOption::has_index3() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogOption::set_has_index3() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogOption::clear_has_index3() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogOption::clear_index3() {
  if (index3_ != &::google::protobuf::internal::kEmptyString) {
    index3_->clear();
  }
  clear_has_index3();
}
inline const ::std::string& LogOption::index3() const {
  return *index3_;
}
inline void LogOption::set_index3(const ::std::string& value) {
  set_has_index3();
  if (index3_ == &::google::protobuf::internal::kEmptyString) {
    index3_ = new ::std::string;
  }
  index3_->assign(value);
}
inline void LogOption::set_index3(const char* value) {
  set_has_index3();
  if (index3_ == &::google::protobuf::internal::kEmptyString) {
    index3_ = new ::std::string;
  }
  index3_->assign(value);
}
inline void LogOption::set_index3(const char* value, size_t size) {
  set_has_index3();
  if (index3_ == &::google::protobuf::internal::kEmptyString) {
    index3_ = new ::std::string;
  }
  index3_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogOption::mutable_index3() {
  set_has_index3();
  if (index3_ == &::google::protobuf::internal::kEmptyString) {
    index3_ = new ::std::string;
  }
  return index3_;
}
inline ::std::string* LogOption::release_index3() {
  clear_has_index3();
  if (index3_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = index3_;
    index3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LogOption::set_allocated_index3(::std::string* index3) {
  if (index3_ != &::google::protobuf::internal::kEmptyString) {
    delete index3_;
  }
  if (index3) {
    set_has_index3();
    index3_ = index3;
  } else {
    clear_has_index3();
    index3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 log_level = 2;
inline bool LogOption::has_log_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogOption::set_has_log_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogOption::clear_has_log_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogOption::clear_log_level() {
  log_level_ = 0u;
  clear_has_log_level();
}
inline ::google::protobuf::uint32 LogOption::log_level() const {
  return log_level_;
}
inline void LogOption::set_log_level(::google::protobuf::uint32 value) {
  set_has_log_level();
  log_level_ = value;
}

// required uint32 count_interval = 3;
inline bool LogOption::has_count_interval() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogOption::set_has_count_interval() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogOption::clear_has_count_interval() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogOption::clear_count_interval() {
  count_interval_ = 0u;
  clear_has_count_interval();
}
inline ::google::protobuf::uint32 LogOption::count_interval() const {
  return count_interval_;
}
inline void LogOption::set_count_interval(::google::protobuf::uint32 value) {
  set_has_count_interval();
  count_interval_ = value;
}

// required uint32 enable_detail = 4;
inline bool LogOption::has_enable_detail() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LogOption::set_has_enable_detail() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LogOption::clear_has_enable_detail() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LogOption::clear_enable_detail() {
  enable_detail_ = 0u;
  clear_has_enable_detail();
}
inline ::google::protobuf::uint32 LogOption::enable_detail() const {
  return enable_detail_;
}
inline void LogOption::set_enable_detail(::google::protobuf::uint32 value) {
  set_has_enable_detail();
  enable_detail_ = value;
}

// -------------------------------------------------------------------

// LogOptions

// optional uint32 log_level = 2;
inline bool LogOptions::has_log_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogOptions::set_has_log_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogOptions::clear_has_log_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogOptions::clear_log_level() {
  log_level_ = 0u;
  clear_has_log_level();
}
inline ::google::protobuf::uint32 LogOptions::log_level() const {
  return log_level_;
}
inline void LogOptions::set_log_level(::google::protobuf::uint32 value) {
  set_has_log_level();
  log_level_ = value;
}

// optional uint32 count_interval = 3;
inline bool LogOptions::has_count_interval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogOptions::set_has_count_interval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogOptions::clear_has_count_interval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogOptions::clear_count_interval() {
  count_interval_ = 0u;
  clear_has_count_interval();
}
inline ::google::protobuf::uint32 LogOptions::count_interval() const {
  return count_interval_;
}
inline void LogOptions::set_count_interval(::google::protobuf::uint32 value) {
  set_has_count_interval();
  count_interval_ = value;
}

// optional uint32 enable_detail = 4;
inline bool LogOptions::has_enable_detail() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogOptions::set_has_enable_detail() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogOptions::clear_has_enable_detail() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogOptions::clear_enable_detail() {
  enable_detail_ = 0u;
  clear_has_enable_detail();
}
inline ::google::protobuf::uint32 LogOptions::enable_detail() const {
  return enable_detail_;
}
inline void LogOptions::set_enable_detail(::google::protobuf::uint32 value) {
  set_has_enable_detail();
  enable_detail_ = value;
}

// repeated .kit.log.LogOption log_option = 1;
inline int LogOptions::log_option_size() const {
  return log_option_.size();
}
inline void LogOptions::clear_log_option() {
  log_option_.Clear();
}
inline const ::kit::log::LogOption& LogOptions::log_option(int index) const {
  return log_option_.Get(index);
}
inline ::kit::log::LogOption* LogOptions::mutable_log_option(int index) {
  return log_option_.Mutable(index);
}
inline ::kit::log::LogOption* LogOptions::add_log_option() {
  return log_option_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kit::log::LogOption >&
LogOptions::log_option() const {
  return log_option_;
}
inline ::google::protobuf::RepeatedPtrField< ::kit::log::LogOption >*
LogOptions::mutable_log_option() {
  return &log_option_;
}

// -------------------------------------------------------------------

// Query

// required string index1 = 1;
inline bool Query::has_index1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Query::set_has_index1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Query::clear_has_index1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Query::clear_index1() {
  if (index1_ != &::google::protobuf::internal::kEmptyString) {
    index1_->clear();
  }
  clear_has_index1();
}
inline const ::std::string& Query::index1() const {
  return *index1_;
}
inline void Query::set_index1(const ::std::string& value) {
  set_has_index1();
  if (index1_ == &::google::protobuf::internal::kEmptyString) {
    index1_ = new ::std::string;
  }
  index1_->assign(value);
}
inline void Query::set_index1(const char* value) {
  set_has_index1();
  if (index1_ == &::google::protobuf::internal::kEmptyString) {
    index1_ = new ::std::string;
  }
  index1_->assign(value);
}
inline void Query::set_index1(const char* value, size_t size) {
  set_has_index1();
  if (index1_ == &::google::protobuf::internal::kEmptyString) {
    index1_ = new ::std::string;
  }
  index1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Query::mutable_index1() {
  set_has_index1();
  if (index1_ == &::google::protobuf::internal::kEmptyString) {
    index1_ = new ::std::string;
  }
  return index1_;
}
inline ::std::string* Query::release_index1() {
  clear_has_index1();
  if (index1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = index1_;
    index1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Query::set_allocated_index1(::std::string* index1) {
  if (index1_ != &::google::protobuf::internal::kEmptyString) {
    delete index1_;
  }
  if (index1) {
    set_has_index1();
    index1_ = index1;
  } else {
    clear_has_index1();
    index1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string index2 = 2;
inline bool Query::has_index2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Query::set_has_index2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Query::clear_has_index2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Query::clear_index2() {
  if (index2_ != &::google::protobuf::internal::kEmptyString) {
    index2_->clear();
  }
  clear_has_index2();
}
inline const ::std::string& Query::index2() const {
  return *index2_;
}
inline void Query::set_index2(const ::std::string& value) {
  set_has_index2();
  if (index2_ == &::google::protobuf::internal::kEmptyString) {
    index2_ = new ::std::string;
  }
  index2_->assign(value);
}
inline void Query::set_index2(const char* value) {
  set_has_index2();
  if (index2_ == &::google::protobuf::internal::kEmptyString) {
    index2_ = new ::std::string;
  }
  index2_->assign(value);
}
inline void Query::set_index2(const char* value, size_t size) {
  set_has_index2();
  if (index2_ == &::google::protobuf::internal::kEmptyString) {
    index2_ = new ::std::string;
  }
  index2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Query::mutable_index2() {
  set_has_index2();
  if (index2_ == &::google::protobuf::internal::kEmptyString) {
    index2_ = new ::std::string;
  }
  return index2_;
}
inline ::std::string* Query::release_index2() {
  clear_has_index2();
  if (index2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = index2_;
    index2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Query::set_allocated_index2(::std::string* index2) {
  if (index2_ != &::google::protobuf::internal::kEmptyString) {
    delete index2_;
  }
  if (index2) {
    set_has_index2();
    index2_ = index2;
  } else {
    clear_has_index2();
    index2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string index3 = 3;
inline bool Query::has_index3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Query::set_has_index3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Query::clear_has_index3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Query::clear_index3() {
  if (index3_ != &::google::protobuf::internal::kEmptyString) {
    index3_->clear();
  }
  clear_has_index3();
}
inline const ::std::string& Query::index3() const {
  return *index3_;
}
inline void Query::set_index3(const ::std::string& value) {
  set_has_index3();
  if (index3_ == &::google::protobuf::internal::kEmptyString) {
    index3_ = new ::std::string;
  }
  index3_->assign(value);
}
inline void Query::set_index3(const char* value) {
  set_has_index3();
  if (index3_ == &::google::protobuf::internal::kEmptyString) {
    index3_ = new ::std::string;
  }
  index3_->assign(value);
}
inline void Query::set_index3(const char* value, size_t size) {
  set_has_index3();
  if (index3_ == &::google::protobuf::internal::kEmptyString) {
    index3_ = new ::std::string;
  }
  index3_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Query::mutable_index3() {
  set_has_index3();
  if (index3_ == &::google::protobuf::internal::kEmptyString) {
    index3_ = new ::std::string;
  }
  return index3_;
}
inline ::std::string* Query::release_index3() {
  clear_has_index3();
  if (index3_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = index3_;
    index3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Query::set_allocated_index3(::std::string* index3) {
  if (index3_ != &::google::protobuf::internal::kEmptyString) {
    delete index3_;
  }
  if (index3) {
    set_has_index3();
    index3_ = index3;
  } else {
    clear_has_index3();
    index3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 begin_time = 7;
inline bool Query::has_begin_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Query::set_has_begin_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Query::clear_has_begin_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Query::clear_begin_time() {
  begin_time_ = GOOGLE_ULONGLONG(0);
  clear_has_begin_time();
}
inline ::google::protobuf::uint64 Query::begin_time() const {
  return begin_time_;
}
inline void Query::set_begin_time(::google::protobuf::uint64 value) {
  set_has_begin_time();
  begin_time_ = value;
}

// optional uint64 end_time = 8;
inline bool Query::has_end_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Query::set_has_end_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Query::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Query::clear_end_time() {
  end_time_ = GOOGLE_ULONGLONG(0);
  clear_has_end_time();
}
inline ::google::protobuf::uint64 Query::end_time() const {
  return end_time_;
}
inline void Query::set_end_time(::google::protobuf::uint64 value) {
  set_has_end_time();
  end_time_ = value;
}

// optional int32 no_sort = 4;
inline bool Query::has_no_sort() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Query::set_has_no_sort() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Query::clear_has_no_sort() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Query::clear_no_sort() {
  no_sort_ = 0;
  clear_has_no_sort();
}
inline ::google::protobuf::int32 Query::no_sort() const {
  return no_sort_;
}
inline void Query::set_no_sort(::google::protobuf::int32 value) {
  set_has_no_sort();
  no_sort_ = value;
}

// optional string condition_clause = 5;
inline bool Query::has_condition_clause() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Query::set_has_condition_clause() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Query::clear_has_condition_clause() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Query::clear_condition_clause() {
  if (condition_clause_ != &::google::protobuf::internal::kEmptyString) {
    condition_clause_->clear();
  }
  clear_has_condition_clause();
}
inline const ::std::string& Query::condition_clause() const {
  return *condition_clause_;
}
inline void Query::set_condition_clause(const ::std::string& value) {
  set_has_condition_clause();
  if (condition_clause_ == &::google::protobuf::internal::kEmptyString) {
    condition_clause_ = new ::std::string;
  }
  condition_clause_->assign(value);
}
inline void Query::set_condition_clause(const char* value) {
  set_has_condition_clause();
  if (condition_clause_ == &::google::protobuf::internal::kEmptyString) {
    condition_clause_ = new ::std::string;
  }
  condition_clause_->assign(value);
}
inline void Query::set_condition_clause(const char* value, size_t size) {
  set_has_condition_clause();
  if (condition_clause_ == &::google::protobuf::internal::kEmptyString) {
    condition_clause_ = new ::std::string;
  }
  condition_clause_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Query::mutable_condition_clause() {
  set_has_condition_clause();
  if (condition_clause_ == &::google::protobuf::internal::kEmptyString) {
    condition_clause_ = new ::std::string;
  }
  return condition_clause_;
}
inline ::std::string* Query::release_condition_clause() {
  clear_has_condition_clause();
  if (condition_clause_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = condition_clause_;
    condition_clause_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Query::set_allocated_condition_clause(::std::string* condition_clause) {
  if (condition_clause_ != &::google::protobuf::internal::kEmptyString) {
    delete condition_clause_;
  }
  if (condition_clause) {
    set_has_condition_clause();
    condition_clause_ = condition_clause;
  } else {
    clear_has_condition_clause();
    condition_clause_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 is_count = 6;
inline bool Query::has_is_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Query::set_has_is_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Query::clear_has_is_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Query::clear_is_count() {
  is_count_ = 0;
  clear_has_is_count();
}
inline ::google::protobuf::int32 Query::is_count() const {
  return is_count_;
}
inline void Query::set_is_count(::google::protobuf::int32 value) {
  set_has_is_count();
  is_count_ = value;
}

// optional int32 limit_a = 9;
inline bool Query::has_limit_a() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Query::set_has_limit_a() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Query::clear_has_limit_a() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Query::clear_limit_a() {
  limit_a_ = 0;
  clear_has_limit_a();
}
inline ::google::protobuf::int32 Query::limit_a() const {
  return limit_a_;
}
inline void Query::set_limit_a(::google::protobuf::int32 value) {
  set_has_limit_a();
  limit_a_ = value;
}

// optional int32 limit_b = 10;
inline bool Query::has_limit_b() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Query::set_has_limit_b() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Query::clear_has_limit_b() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Query::clear_limit_b() {
  limit_b_ = 0;
  clear_has_limit_b();
}
inline ::google::protobuf::int32 Query::limit_b() const {
  return limit_b_;
}
inline void Query::set_limit_b(::google::protobuf::int32 value) {
  set_has_limit_b();
  limit_b_ = value;
}

// optional string username = 11;
inline bool Query::has_username() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Query::set_has_username() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Query::clear_has_username() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Query::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& Query::username() const {
  return *username_;
}
inline void Query::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void Query::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void Query::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Query::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* Query::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Query::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 12;
inline bool Query::has_password() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Query::set_has_password() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Query::clear_has_password() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Query::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& Query::password() const {
  return *password_;
}
inline void Query::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void Query::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void Query::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Query::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* Query::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Query::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// QueryResult

// repeated .kit.log.LogEvent log_event = 1;
inline int QueryResult::log_event_size() const {
  return log_event_.size();
}
inline void QueryResult::clear_log_event() {
  log_event_.Clear();
}
inline const ::kit::log::LogEvent& QueryResult::log_event(int index) const {
  return log_event_.Get(index);
}
inline ::kit::log::LogEvent* QueryResult::mutable_log_event(int index) {
  return log_event_.Mutable(index);
}
inline ::kit::log::LogEvent* QueryResult::add_log_event() {
  return log_event_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kit::log::LogEvent >&
QueryResult::log_event() const {
  return log_event_;
}
inline ::google::protobuf::RepeatedPtrField< ::kit::log::LogEvent >*
QueryResult::mutable_log_event() {
  return &log_event_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace log
}  // namespace kit

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_log_2flog_2eproto__INCLUDED
